{% extends "rag/base_sidebar.html" %}

{% block page_title %}è©•ä¼°çŸ©é™£ Heatmap{% endblock %}

{% block page_content %}
<div class="mb-6">
    <h2 class="text-3xl font-bold text-gray-800 mb-2">ğŸ“Š è©•ä¼°çŸ©é™£ç¸½è¦½</h2>
    <p class="text-gray-600">è¦–è¦ºåŒ–æ¯”è¼ƒä¸åŒ Chunk ç­–ç•¥èˆ‡æ¸¬è©¦é›†çš„è©•ä¼°çµæœ</p>
</div>

<!-- Loading State -->
<div id="loadingState" class="flex justify-center items-center py-20">
    <div class="text-center">
        <div class="animate-spin rounded-full h-16 w-16 border-b-2 border-indigo-600 mx-auto mb-4"></div>
        <p class="text-gray-600">è¼‰å…¥è©•ä¼°çŸ©é™£æ•¸æ“šä¸­...</p>
    </div>
</div>

<!-- Matrix Container -->
<div id="matrixContainer" class="hidden">
    <!-- Filters and Controls -->
    <div class="bg-white rounded-lg shadow-sm p-4 mb-6">
        <!-- Prompt Version Filter -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-700 mb-2">ç¯©é¸ Prompt ç‰ˆæœ¬</h3>
            <div class="flex gap-2 flex-wrap" id="promptFilters">
                <button onclick="filterPromptVersion('all')"
                        class="prompt-filter-btn px-4 py-2 rounded-lg font-medium transition active"
                        data-version="all">
                    å…¨éƒ¨ç‰ˆæœ¬
                </button>
                <!-- Dynamic prompt version buttons will be added here -->
            </div>
        </div>

        <!-- Metric Selector -->
        <div class="flex items-center justify-between mb-4">
            <h3 class="text-sm font-semibold text-gray-700">é¸æ“‡è©•ä¼°æŒ‡æ¨™</h3>
            <div class="flex gap-2">
                <button onclick="runAllExperiments()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition font-semibold">
                    ğŸš€ åŸ·è¡Œæ‰€æœ‰çµ„åˆ
                </button>
                <button onclick="refreshMatrix()" class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition text-sm">
                    ğŸ”„ é‡æ–°è¼‰å…¥
                </button>
            </div>
        </div>
        <div class="flex gap-3 flex-wrap">
            <button onclick="setMetric('avg_faithfulness')"
                    class="metric-btn px-4 py-2 rounded-lg font-medium transition text-sm"
                    data-metric="avg_faithfulness">
                Faithfulness
            </button>
            <button onclick="setMetric('avg_answer_relevancy')"
                    class="metric-btn px-4 py-2 rounded-lg font-medium transition active text-sm"
                    data-metric="avg_answer_relevancy">
                Answer Relevancy
            </button>
            <button onclick="setMetric('avg_context_recall')"
                    class="metric-btn px-4 py-2 rounded-lg font-medium transition text-sm"
                    data-metric="avg_context_recall">
                Context Recall
            </button>
            <button onclick="setMetric('avg_context_precision')"
                    class="metric-btn px-4 py-2 rounded-lg font-medium transition text-sm"
                    data-metric="avg_context_precision">
                Context Precision
            </button>
        </div>
    </div>

    <!-- Heatmap Matrix -->
    <div class="bg-white rounded-lg shadow-lg p-6">
        <div class="overflow-x-auto">
            <table class="w-full border-collapse text-sm" id="heatmapTable">
                <thead>
                    <tr class="border-b-2 border-gray-300">
                        <th class="p-3 text-left font-bold text-gray-700 sticky left-0 bg-white z-10 w-32">
                            Chunk ç­–ç•¥
                        </th>
                        <th class="p-3 text-center font-bold text-gray-700 bg-white z-10 w-24">
                            Prompt
                        </th>
                        <!-- Test set headers will be inserted here -->
                        <th class="p-3 text-center font-bold text-gray-700 bg-white z-10 w-28">
                            æ“ä½œ
                        </th>
                    </tr>
                </thead>
                <tbody id="heatmapBody">
                    <!-- Matrix rows will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Legend -->
    <div class="mt-6 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4">
        <h4 class="font-semibold text-gray-800 mb-3">ğŸ“– åœ–ä¾‹èªªæ˜</h4>
        <div class="grid grid-cols-2 gap-4">
            <div>
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-4 h-4 rounded" style="background: linear-gradient(to right, #fee2e2, #dc2626)"></div>
                    <span class="text-sm text-gray-700">é¡è‰²æ·±æ·ºï¼šåˆ†æ•¸é«˜ä½ (ç¶ è‰²=é«˜åˆ†, ç´…è‰²=ä½åˆ†)</span>
                </div>
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-4 h-4 bg-gray-100 border-2 border-dashed border-gray-400 rounded"></div>
                    <span class="text-sm text-gray-700">è™›ç·šæ¡†ï¼šç„¡è©•ä¼°æ•¸æ“š</span>
                </div>
            </div>
            <div>
                <div class="text-sm text-gray-700 mb-1">
                    <strong>é»æ“Šæ ¼å­ï¼š</strong>æŸ¥çœ‹å¯¦é©—è©³æƒ…
                </div>
                <div class="text-sm text-gray-700">
                    <strong>Instruction Versionï¼š</strong>Prompt ç‰ˆæœ¬ç·¨è™Ÿ
                </div>
            </div>
        </div>
    </div>

    <!-- Statistics Summary -->
    <div class="mt-6 grid grid-cols-4 gap-4">
        <div class="bg-white rounded-lg shadow p-4">
            <div class="text-sm text-gray-600 mb-1">ç¸½å¯¦é©—æ•¸</div>
            <div class="text-2xl font-bold text-gray-800" id="totalExperiments">-</div>
        </div>
        <div class="bg-white rounded-lg shadow p-4">
            <div class="text-sm text-gray-600 mb-1">æœ€ä½³ç­–ç•¥</div>
            <div class="text-2xl font-bold text-green-600" id="bestStrategy">-</div>
        </div>
        <div class="bg-white rounded-lg shadow p-4">
            <div class="text-sm text-gray-600 mb-1">å¹³å‡åˆ†æ•¸</div>
            <div class="text-2xl font-bold text-blue-600" id="avgScore">-</div>
        </div>
        <div class="bg-white rounded-lg shadow p-4">
            <div class="text-sm text-gray-600 mb-1">å®Œæˆåº¦</div>
            <div class="text-2xl font-bold text-indigo-600" id="completionRate">-</div>
        </div>
    </div>
</div>

<!-- Error State -->
<div id="errorState" class="hidden bg-red-50 border border-red-200 rounded-lg p-6 text-center">
    <div class="text-4xl mb-4">âš ï¸</div>
    <h3 class="text-xl font-semibold text-red-800 mb-2">è¼‰å…¥å¤±æ•—</h3>
    <p class="text-red-600 mb-4" id="errorMessage">ç„¡æ³•è¼‰å…¥è©•ä¼°çŸ©é™£æ•¸æ“š</p>
    <button onclick="loadMatrix()" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">
        é‡è©¦
    </button>
</div>

<script>
let matrixData = null;
let currentMetric = 'avg_answer_relevancy';
let currentPromptFilter = 'all';

// Color scale for heatmap
function getColor(value) {
    if (value === null || value === undefined) return '#f3f4f6'; // gray-100

    // Green (high) to Red (low) scale
    const normalized = value; // Assuming 0-1 scale
    if (normalized >= 0.8) return '#10b981'; // green-500
    if (normalized >= 0.6) return '#84cc16'; // lime-500
    if (normalized >= 0.4) return '#fbbf24'; // amber-400
    if (normalized >= 0.2) return '#f97316'; // orange-500
    return '#ef4444'; // red-500
}

// Format metric value
function formatMetric(value) {
    if (value === null || value === undefined) return 'N/A';
    return value.toFixed(3);
}

// Load matrix data from API
async function loadMatrix() {
    try {
        document.getElementById('loadingState').classList.remove('hidden');
        document.getElementById('matrixContainer').classList.add('hidden');
        document.getElementById('errorState').classList.add('hidden');

        const response = await fetch('/api/rag/evaluation/experiments/matrix');
        if (!response.ok) throw new Error('Failed to load matrix data');

        matrixData = await response.json();
        initializePromptFilters();
        renderMatrix();

        document.getElementById('loadingState').classList.add('hidden');
        document.getElementById('matrixContainer').classList.remove('hidden');
    } catch (error) {
        console.error('Error loading matrix:', error);
        document.getElementById('loadingState').classList.add('hidden');
        document.getElementById('errorState').classList.remove('hidden');
        document.getElementById('errorMessage').textContent = error.message;
    }
}

// Initialize prompt version filter buttons
function initializePromptFilters() {
    if (!matrixData) return;

    const { prompts } = matrixData;
    const promptVersions = prompts.map(p => p.version).sort();

    // Create filter buttons
    const filtersContainer = document.getElementById('promptFilters');

    promptVersions.forEach(version => {
        const btn = document.createElement('button');
        btn.className = 'prompt-filter-btn px-4 py-2 rounded-lg font-medium transition bg-gray-100 text-gray-700';
        btn.dataset.version = version;
        btn.textContent = `v${version}`;
        btn.onclick = () => filterPromptVersion(version);
        filtersContainer.appendChild(btn);
    });
}

// Filter by prompt version
function filterPromptVersion(version) {
    currentPromptFilter = version;

    // Update button styles
    document.querySelectorAll('.prompt-filter-btn').forEach(btn => {
        if (btn.dataset.version === version) {
            btn.classList.add('active', 'bg-indigo-600', 'text-white');
            btn.classList.remove('bg-gray-100', 'text-gray-700');
        } else {
            btn.classList.remove('active', 'bg-indigo-600', 'text-white');
            btn.classList.add('bg-gray-100', 'text-gray-700');
        }
    });

    renderMatrix();
}

// Render heatmap matrix with 3 dimensions: Chunk Strategy | Prompt | Test Sets
function renderMatrix() {
    if (!matrixData) return;

    const { testsets, prompts, chunk_strategies, experiments } = matrixData;

    // Build cells lookup: cells[chunk_strategy][prompt_version][testset] = experiment
    const cells = {};

    // Initialize cells structure for ALL combinations from chunk_strategies Ã— prompts
    chunk_strategies.forEach(cs => {
        cells[cs.name] = {};
        prompts.forEach(p => {
            cells[cs.name][p.version] = {};
            // Initialize all testsets for this combination
            testsets.forEach(ts => {
                cells[cs.name][p.version][ts.name] = null;
            });
        });
    });

    // Populate cells with experiments data where available
    experiments.forEach(exp => {
        const strategyName = exp.chunk_strategy;
        const promptVersion = exp.instruction_version;

        if (!strategyName || !promptVersion) return;

        // Try to match experiment to a chunk strategy
        // For now, assign to first testset as placeholder until we add testset_id
        const firstTestset = testsets[0]?.name;

        // Find matching chunk_strategy from API
        // Match by comparing chunk_size and chunk_overlap
        const matchingStrategy = chunk_strategies.find(cs => {
            return exp.chunk_size === cs.chunk_size && exp.chunk_overlap === cs.chunk_overlap;
        });

        const strategyKey = matchingStrategy ? matchingStrategy.name : strategyName;

        if (cells[strategyKey] && cells[strategyKey][promptVersion] && firstTestset) {
            cells[strategyKey][promptVersion][firstTestset] = exp;
        }
    });

    const strategies = chunk_strategies.map(cs => cs.name);
    const test_sets = testsets.map(ts => ts.name);

    // Render table headers: Chunk Strategy | Prompt | Testset1 | Testset2 | ...
    const thead = document.querySelector('#heatmapTable thead tr');
    thead.innerHTML = `
        <th class="p-3 text-left font-bold text-gray-700 border-b-2 border-gray-300 sticky left-0 bg-white z-10 w-32">
            Chunk ç­–ç•¥
        </th>
        <th class="p-3 text-center font-bold text-gray-700 border-b-2 border-gray-300 bg-white z-10 w-24">
            Prompt
        </th>
    `;

    // Column headers for each testset
    test_sets.forEach(testSet => {
        thead.innerHTML += `
            <th class="p-3 text-center font-bold text-gray-700 border-b-2 border-gray-300 min-w-[150px]">
                ${testSet}
            </th>
        `;
    });

    // Add action column header
    thead.innerHTML += `
        <th class="p-3 text-center font-bold text-gray-700 border-b-2 border-gray-300 bg-white z-10 w-32">
            æ“ä½œ
        </th>
    `;

    // Generate ALL combinations from chunk_strategies Ã— prompts (complete matrix)
    const combinations = [];
    strategies.forEach(strategy => {
        prompts.forEach(p => {
            combinations.push({ strategy, version: p.version });
        });
    });

    // Render table body
    const tbody = document.getElementById('heatmapBody');
    tbody.innerHTML = '';

    let totalCells = 0;
    let completedCells = 0;
    let sumScores = 0;
    let scoreCount = 0;
    const strategyScores = {};

    combinations.forEach(({ strategy, version }) => {
        // Apply prompt version filter
        if (currentPromptFilter !== 'all' && version !== currentPromptFilter) {
            return;
        }

        const row = document.createElement('tr');
        row.className = 'border-b border-gray-200 hover:bg-gray-50';

        // Get chunk strategy details from chunk_strategies API
        const strategyObj = chunk_strategies.find(cs => cs.name === strategy);
        const strategyInfo = strategyObj
            ? `${strategyObj.type} (${strategyObj.chunk_size}/${strategyObj.chunk_overlap})`
            : strategy;

        // Chunk Strategy column
        row.innerHTML = `
            <td class="p-3 font-medium text-gray-800 border-r border-gray-200 sticky left-0 bg-white z-10">
                <div class="font-semibold">${strategy}</div>
                <div class="text-xs text-gray-500 mt-1">${strategyInfo}</div>
            </td>
        `;

        // Prompt Version column
        row.innerHTML += `
            <td class="p-2 text-center font-medium text-indigo-600 border-r border-gray-200 bg-white z-10">
                ${version ? `v${version}` : '-'}
            </td>
        `;

        // Test Set columns
        let firstExperimentId = null;
        test_sets.forEach(testSet => {
            totalCells++;

            const cell = cells[strategy] && cells[strategy][version] && cells[strategy][version][testSet];

            if (cell) {
                completedCells++;
                const metricValue = cell[currentMetric];
                const color = getColor(metricValue);

                if (metricValue !== null && metricValue !== undefined) {
                    sumScores += metricValue;
                    scoreCount++;

                    const key = `${strategy}_v${version}`;
                    if (!strategyScores[key]) strategyScores[key] = [];
                    strategyScores[key].push(metricValue);
                }

                // Store first experiment ID for re-run action
                if (!firstExperimentId) firstExperimentId = cell.experiment_id;

                const cellHtml = `
                    <td class="p-2 text-center cursor-pointer transition hover:shadow-lg"
                        style="background-color: ${color}; color: ${metricValue > 0.5 ? 'white' : '#1f2937'}"
                        onclick="showExperimentDetail('${cell.experiment_id}')">
                        <div class="font-bold text-lg mb-1">${formatMetric(metricValue)}</div>
                        <div class="text-xs opacity-80">
                            ${cell.total_queries} queries
                        </div>
                    </td>
                `;
                row.innerHTML += cellHtml;
            } else {
                row.innerHTML += `
                    <td class="p-2 text-center bg-gray-100 border-2 border-dashed border-gray-300">
                        <div class="text-gray-400 text-sm">æœªè©•ä¼°</div>
                    </td>
                `;
            }
        });

        // Add action column with run button
        row.innerHTML += `
            <td class="p-2 text-center">
                <button onclick="runSingleRow('${strategy}', '${version}')"
                        class="px-3 py-1.5 bg-indigo-600 text-white rounded-lg text-xs hover:bg-indigo-700 transition disabled:bg-gray-300"
                        id="run-${strategy.replace(/[^a-zA-Z0-9]/g, '_')}-${version}"
                        title="åŸ·è¡Œæ­¤çµ„åˆçš„æ‰€æœ‰æ¸¬è©¦é›†">
                    â–¶ åŸ·è¡Œ
                </button>
            </td>
        `;

        tbody.appendChild(row);
    });

    // Update statistics
    document.getElementById('totalExperiments').textContent = completedCells;
    document.getElementById('avgScore').textContent = scoreCount > 0 ? (sumScores / scoreCount).toFixed(3) : 'N/A';
    document.getElementById('completionRate').textContent = `${Math.round((completedCells / totalCells) * 100)}%`;

    // Find best strategy+prompt combination
    let bestStrategy = '';
    let bestAvg = -1;
    Object.entries(strategyScores).forEach(([key, scores]) => {
        const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
        if (avg > bestAvg) {
            bestAvg = avg;
            bestStrategy = key.replace('_', ' ');
        }
    });
    document.getElementById('bestStrategy').textContent = bestStrategy || 'N/A';
}

// Set active metric
function setMetric(metric) {
    currentMetric = metric;

    // Update button styles
    document.querySelectorAll('.metric-btn').forEach(btn => {
        if (btn.dataset.metric === metric) {
            btn.classList.add('active', 'bg-indigo-600', 'text-white');
            btn.classList.remove('bg-gray-100', 'text-gray-700');
        } else {
            btn.classList.remove('active', 'bg-indigo-600', 'text-white');
            btn.classList.add('bg-gray-100', 'text-gray-700');
        }
    });

    renderMatrix();
}

// Show experiment detail
function showExperimentDetail(experimentId) {
    window.location.href = `/rag/evaluation/experiments/${experimentId}`;
}

// Refresh matrix
function refreshMatrix() {
    loadMatrix();
}

// Re-run experiments for a specific strategy + prompt combination
async function rerunExperiments(strategy, promptVersion) {
    const btnId = `rerun-${strategy}-${promptVersion || 'none'}`;
    const btn = document.getElementById(btnId);

    if (!confirm(`ç¢ºå®šè¦é‡æ–°åŸ·è¡Œã€Œ${strategy}${promptVersion ? ' (v' + promptVersion + ')' : ''}ã€çš„æ‰€æœ‰æ¸¬è©¦é›†å—ï¼Ÿ\n\né€™å°‡æœƒï¼š\nâœ“ åŸ·è¡Œæ‰€æœ‰ 4 å€‹æ¸¬è©¦é›†çš„è©•ä¼°\nâœ“ åŒ…å«æ‰€æœ‰ 4 å€‹ RAGAS æŒ‡æ¨™\nâœ“ å¯èƒ½éœ€è¦å¹¾åˆ†é˜æ™‚é–“`)) {
        return;
    }

    btn.disabled = true;
    btn.textContent = 'â³ åŸ·è¡Œä¸­...';

    const { test_sets, cells } = matrixData;
    const results = [];

    try {
        // For each test set, re-run the evaluation
        for (const testSet of test_sets) {
            const cell = cells[strategy][testSet];

            if (!cell) {
                console.log(`Skipping ${testSet} - no existing experiment`);
                continue;
            }

            // Get the experiment details to extract test cases
            const expResponse = await fetch(`/api/rag/evaluation/experiments/${cell.experiment_id}/results`);
            if (!expResponse.ok) {
                throw new Error(`Failed to load experiment ${cell.experiment_id}`);
            }

            const testCases = await expResponse.json();

            // Create new experiment
            const createResponse = await fetch('/api/rag/evaluation/experiments', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: `[é‡æ–°åŸ·è¡Œ] ${cell.name}`,
                    description: `é‡æ–°åŸ·è¡Œè©•ä¼°ï¼ŒåŒ…å«æ‰€æœ‰ 4 å€‹ RAGAS æŒ‡æ¨™`,
                    experiment_type: 'end_to_end',
                    chunking_method: cell.chunking_method || 'recursive',
                    chunk_size: cell.chunk_size || 256,
                    chunk_overlap: cell.chunk_overlap || 50,
                    chunk_strategy: strategy,
                    instruction_version: promptVersion || '2.0'
                })
            });

            if (!createResponse.ok) {
                throw new Error(`Failed to create experiment for ${testSet}`);
            }

            const newExp = await createResponse.json();

            // Run evaluation with all metrics
            const evalResponse = await fetch(`/api/rag/evaluation/experiments/${newExp.id}/run`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    test_cases: testCases.map(tc => ({
                        question: tc.question,
                        answer: tc.answer,
                        contexts: tc.contexts,
                        ground_truth: tc.ground_truth
                    })),
                    include_ground_truth: true
                })
            });

            if (!evalResponse.ok) {
                throw new Error(`Failed to run evaluation for ${testSet}`);
            }

            const result = await evalResponse.json();
            results.push(result);

            btn.textContent = `â³ ${results.length}/${test_sets.length}`;
        }

        btn.textContent = 'âœ… å®Œæˆ';
        btn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
        btn.classList.add('bg-green-600');

        setTimeout(() => {
            alert(`âœ… é‡æ–°åŸ·è¡Œå®Œæˆï¼\n\nå·²å®Œæˆ ${results.length} å€‹æ¸¬è©¦é›†çš„è©•ä¼°\né é¢å°‡è‡ªå‹•é‡æ–°è¼‰å…¥`);
            location.reload();
        }, 500);

    } catch (error) {
        console.error('Re-run failed:', error);
        btn.textContent = 'âŒ å¤±æ•—';
        btn.classList.remove('bg-indigo-600');
        btn.classList.add('bg-red-600');
        alert(`é‡æ–°åŸ·è¡Œå¤±æ•—ï¼š${error.message}`);

        setTimeout(() => {
            btn.disabled = false;
            btn.textContent = 'ğŸ”„ é‡æ–°åŸ·è¡Œ';
            btn.classList.remove('bg-red-600');
            btn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }, 2000);
    }
}

// Run single row (one chunk_strategy Ã— prompt combination across all testsets)
async function runSingleRow(strategy, promptVersion) {
    const total = matrixData.testsets.length;

    const strategyObj = matrixData.chunk_strategies.find(cs => cs.name === strategy);
    if (!strategyObj) {
        showToast('æ‰¾ä¸åˆ° Chunk ç­–ç•¥', 'error');
        return;
    }

    // Create progress modal
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-2xl p-8 max-w-lg w-full">
            <h3 class="text-2xl font-bold text-gray-800 mb-2">${strategy} Ã— v${promptVersion}</h3>
            <p class="text-gray-600 mb-4">åŸ·è¡Œä¸­...</p>

            <div class="mb-4">
                <div class="flex justify-between text-sm text-gray-600 mb-2">
                    <span>é€²åº¦</span>
                    <span id="row-progress-text">0 / ${total}</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-4">
                    <div id="row-progress-bar" class="bg-indigo-600 h-4 rounded-full transition-all" style="width: 0%"></div>
                </div>
            </div>

            <div class="text-sm text-gray-600 mb-4">
                <div id="row-current-task" class="text-indigo-600 font-medium">æº–å‚™ä¸­...</div>
            </div>

            <div class="grid grid-cols-2 gap-4 text-sm">
                <div class="bg-green-50 p-3 rounded">
                    <div class="text-gray-600">âœ… æˆåŠŸ</div>
                    <div class="text-2xl font-bold text-green-600" id="row-success">0</div>
                </div>
                <div class="bg-red-50 p-3 rounded">
                    <div class="text-gray-600">âŒ å¤±æ•—</div>
                    <div class="text-2xl font-bold text-red-600" id="row-failed">0</div>
                </div>
            </div>

            <div id="row-results" class="mt-4 hidden">
                <h4 class="font-semibold text-gray-800 mb-2">åŸ·è¡Œçµæœï¼š</h4>
                <div class="bg-gray-50 p-4 rounded max-h-48 overflow-y-auto">
                    <div id="row-results-list"></div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    let completed = 0;
    let failed = 0;
    const results = [];

    try {
        for (const testset of matrixData.testsets) {
            document.getElementById('row-current-task').textContent = `æ­£åœ¨åŸ·è¡Œï¼š${testset.name}`;

            try {
                // Create experiment
                const createResponse = await fetch('/api/rag/evaluation/experiments', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: `${strategy}_v${promptVersion}_${testset.name}`,
                        description: `Auto-generated: ${strategy} + Prompt v${promptVersion} on ${testset.name}`,
                        experiment_type: 'end_to_end',
                        chunking_method: strategyObj.type,
                        chunk_size: strategyObj.chunk_size,
                        chunk_overlap: strategyObj.chunk_overlap,
                        chunk_strategy: strategy,
                        instruction_version: promptVersion
                    })
                });

                if (!createResponse.ok) {
                    throw new Error(`å»ºç«‹å¯¦é©—å¤±æ•—`);
                }

                const newExp = await createResponse.json();

                // Get testset questions
                const testsetResponse = await fetch(`/api/rag/evaluation/testsets/${testset.id}`);
                if (!testsetResponse.ok) {
                    throw new Error(`è¼‰å…¥æ¸¬è©¦é›†å¤±æ•—`);
                }

                const testsetData = await testsetResponse.json();
                const testCases = testsetData.test_cases || [];

                // Run evaluation
                const evalResponse = await fetch(`/api/rag/evaluation/experiments/${newExp.id}/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        test_cases: testCases,
                        include_ground_truth: true
                    })
                });

                if (!evalResponse.ok) {
                    const errorData = await evalResponse.json().catch(() => ({}));
                    const errorMsg = errorData.detail || errorData.message || `HTTP ${evalResponse.status}`;
                    throw new Error(`è©•ä¼°åŸ·è¡Œå¤±æ•—: ${errorMsg}`);
                }

                const evalResult = await evalResponse.json();

                completed++;
                document.getElementById('row-success').textContent = completed;

                results.push({
                    testset: testset.name,
                    success: true,
                    metrics: evalResult.metrics || {}
                });

            } catch (error) {
                console.error(`Failed on ${testset.name}:`, error);
                failed++;
                document.getElementById('row-failed').textContent = failed;

                results.push({
                    testset: testset.name,
                    success: false,
                    error: error.message
                });
            }

            // Update progress
            const totalDone = completed + failed;
            const percent = Math.round((totalDone / total) * 100);
            document.getElementById('row-progress-bar').style.width = `${percent}%`;
            document.getElementById('row-progress-text').textContent = `${totalDone} / ${total}`;
        }

        // Show results
        document.getElementById('row-current-task').textContent = `âœ… åŸ·è¡Œå®Œæˆï¼`;
        document.getElementById('row-results').classList.remove('hidden');

        const resultsList = document.getElementById('row-results-list');
        results.forEach(r => {
            const item = document.createElement('div');
            item.className = 'mb-2 pb-2 border-b border-gray-200 last:border-0';
            if (r.success) {
                const metrics = r.metrics;
                item.innerHTML = `
                    <div class="font-medium text-green-600">âœ… ${r.testset}</div>
                    <div class="text-xs text-gray-600 mt-1">
                        Faithfulness: ${(metrics.avg_faithfulness || 0).toFixed(3)} |
                        Answer Relevancy: ${(metrics.avg_answer_relevancy || 0).toFixed(3)} |
                        Context Recall: ${(metrics.avg_context_recall || 0).toFixed(3)} |
                        Context Precision: ${(metrics.avg_context_precision || 0).toFixed(3)}
                    </div>
                `;
            } else {
                item.innerHTML = `
                    <div class="font-medium text-red-600">âŒ ${r.testset}</div>
                    <div class="text-xs text-red-500">${r.error}</div>
                `;
            }
            resultsList.appendChild(item);
        });

        // Add close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'mt-4 w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition';
        closeBtn.textContent = 'é—œé–‰ä¸¦é‡æ–°è¼‰å…¥';
        closeBtn.onclick = () => {
            modal.remove();
            loadMatrix();
        };
        modal.querySelector('.bg-white').appendChild(closeBtn);

        showToast(`âœ… åŸ·è¡Œå®Œæˆï¼æˆåŠŸ ${completed} å€‹ï¼Œå¤±æ•— ${failed} å€‹`, 'success');

    } catch (error) {
        console.error('Run failed:', error);
        document.getElementById('row-current-task').textContent = `âŒ åŸ·è¡Œå¤±æ•—ï¼š${error.message}`;
        showToast(`åŸ·è¡Œå¤±æ•—ï¼š${error.message}`, 'error');
    }
}

// Run all combinations (all chunk_strategies Ã— prompts Ã— testsets)
async function runAllExperiments() {
    const totalCombinations = matrixData.chunk_strategies.length * matrixData.prompts.length * matrixData.testsets.length;

    let completed = 0;
    let failed = 0;

    // Create progress modal
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-2xl p-8 max-w-md w-full">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">æ‰¹æ¬¡åŸ·è¡Œä¸­...</h3>
            <div class="mb-4">
                <div class="flex justify-between text-sm text-gray-600 mb-2">
                    <span>é€²åº¦</span>
                    <span id="batch-progress-text">0 / ${totalCombinations}</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-4">
                    <div id="batch-progress-bar" class="bg-indigo-600 h-4 rounded-full transition-all" style="width: 0%"></div>
                </div>
            </div>
            <div class="text-sm text-gray-600">
                <div>âœ… æˆåŠŸ: <span id="batch-success">0</span></div>
                <div>âŒ å¤±æ•—: <span id="batch-failed">0</span></div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    for (const strategy of matrixData.chunk_strategies) {
        for (const prompt of matrixData.prompts) {
            for (const testset of matrixData.testsets) {
                try {
                    // Create experiment
                    const createResponse = await fetch('/api/rag/evaluation/experiments', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: `${strategy.name}_v${prompt.version}_${testset.name}`,
                            description: `Batch run: ${strategy.name} + Prompt v${prompt.version} on ${testset.name}`,
                            experiment_type: 'end_to_end',
                            chunking_method: strategy.type,
                            chunk_size: strategy.chunk_size,
                            chunk_overlap: strategy.chunk_overlap,
                            chunk_strategy: strategy.name,
                            instruction_version: prompt.version
                        })
                    });

                    if (!createResponse.ok) throw new Error('Create failed');

                    const newExp = await createResponse.json();

                    // Get testset questions
                    const testsetResponse = await fetch(`/api/rag/evaluation/testsets/${testset.id}`);
                    if (!testsetResponse.ok) throw new Error('Testset load failed');

                    const testsetData = await testsetResponse.json();
                    const testCases = testsetData.test_cases || [];

                    // Run evaluation
                    const evalResponse = await fetch(`/api/rag/evaluation/experiments/${newExp.id}/run`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            test_cases: testCases,
                            include_ground_truth: true
                        })
                    });

                    if (!evalResponse.ok) throw new Error('Eval failed');

                    completed++;
                    document.getElementById('batch-success').textContent = completed;
                } catch (error) {
                    console.error('Experiment failed:', error);
                    failed++;
                    document.getElementById('batch-failed').textContent = failed;
                }

                // Update progress
                const total = completed + failed;
                const percent = Math.round((total / totalCombinations) * 100);
                document.getElementById('batch-progress-bar').style.width = `${percent}%`;
                document.getElementById('batch-progress-text').textContent = `${total} / ${totalCombinations}`;
            }
        }
    }

    // Done
    modal.remove();
    showToast(`âœ… æ‰¹æ¬¡åŸ·è¡Œå®Œæˆï¼æˆåŠŸ ${completed} å€‹ï¼Œå¤±æ•— ${failed} å€‹`, 'success');
    loadMatrix();
}

// Toast notification
function showToast(message, type = 'info') {
    let toast = document.getElementById('toast');
    if (!toast) {
        toast = document.createElement('div');
        toast.id = 'toast';
        toast.className = 'fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg transition-opacity z-50';
        document.body.appendChild(toast);
    }

    toast.classList.remove('hidden', 'bg-green-600', 'bg-red-600', 'bg-blue-600', 'bg-gray-800');

    if (type === 'success') {
        toast.classList.add('bg-green-600', 'text-white');
    } else if (type === 'error') {
        toast.classList.add('bg-red-600', 'text-white');
    } else {
        toast.classList.add('bg-blue-600', 'text-white');
    }

    toast.textContent = message;
    toast.classList.remove('hidden');

    setTimeout(() => {
        toast.classList.add('hidden');
    }, 5000);
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    loadMatrix();
});
</script>

<style>
.metric-btn.active {
    background-color: #4f46e5;
    color: white;
}
.prompt-filter-btn.active {
    background-color: #4f46e5;
    color: white;
}
</style>

{% endblock %}
