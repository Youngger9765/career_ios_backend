{% extends "rag/base_sidebar.html" %}

{% block page_title %}è©•ä¼°çŸ©é™£ç¸½è¦½{% endblock %}

{% block page_content %}
<div class="mb-6 flex justify-between items-center">
    <div>
        <h2 class="text-3xl font-bold text-gray-800 mb-2">ğŸ“Š è©•ä¼°çŸ©é™£ç¸½è¦½</h2>
        <p class="text-gray-600">å®Œæ•´çš„ä¸‰ç¶­è©•ä¼°çŸ©é™£ï¼šæ¸¬è©¦é›† Ã— Prompt Ã— Chunk ç­–ç•¥</p>
    </div>
    <button onclick="runAllExperiments()"
            class="px-6 py-3 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white rounded-lg transition font-semibold shadow-lg flex items-center gap-2">
        <span>ğŸš€</span>
        <span>æ‰¹æ¬¡åŸ·è¡Œå…¨éƒ¨</span>
    </button>
</div>

<!-- Stats Cards -->
<div class="grid grid-cols-5 gap-4 mb-6">
    <div class="bg-white rounded-lg p-4 shadow-md border border-gray-200">
        <div class="text-gray-600 text-sm mb-1">ç¸½çµ„åˆæ•¸</div>
        <div class="text-3xl font-bold text-blue-600" id="totalCombinations">0</div>
    </div>
    <div class="bg-white rounded-lg p-4 shadow-md border border-gray-200">
        <div class="text-gray-600 text-sm mb-1">å·²å®Œæˆ</div>
        <div class="text-3xl font-bold text-green-600" id="completedCount">0</div>
    </div>
    <div class="bg-white rounded-lg p-4 shadow-md border border-gray-200">
        <div class="text-gray-600 text-sm mb-1">å¾…åŸ·è¡Œ</div>
        <div class="text-3xl font-bold text-orange-600" id="pendingCount">0</div>
    </div>
    <div class="bg-white rounded-lg p-4 shadow-md border border-gray-200">
        <div class="text-gray-600 text-sm mb-1">é‹è¡Œä¸­</div>
        <div class="text-3xl font-bold text-purple-600" id="runningCount">0</div>
    </div>
    <div class="bg-white rounded-lg p-4 shadow-md border border-gray-200">
        <div class="text-gray-600 text-sm mb-1">å®Œæˆç‡</div>
        <div class="text-3xl font-bold text-indigo-600" id="completionRate">0%</div>
    </div>
</div>

<!-- Filters -->
<div class="bg-white rounded-lg shadow-md border border-gray-200 p-4 mb-6">
    <div class="grid grid-cols-3 gap-6">
        <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">ç¯©é¸æ¸¬è©¦é›†</label>
            <select id="filterTestset" onchange="applyFilters()" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
                <option value="all">å…¨éƒ¨æ¸¬è©¦é›†</option>
            </select>
        </div>
        <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">ç¯©é¸ Prompt</label>
            <select id="filterPrompt" onchange="applyFilters()" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
                <option value="all">å…¨éƒ¨ Prompt</option>
            </select>
        </div>
        <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">ç¯©é¸ Chunk ç­–ç•¥</label>
            <select id="filterChunk" onchange="applyFilters()" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
                <option value="all">å…¨éƒ¨ç­–ç•¥</option>
            </select>
        </div>
    </div>
</div>

<!-- Matrix Table -->
<div class="bg-white rounded-lg shadow-lg border border-gray-200">
    <div class="p-4 border-b border-gray-200 flex justify-between items-center">
        <h3 class="text-lg font-bold text-gray-800">å¯¦é©—çµ„åˆåˆ—è¡¨</h3>
        <div class="flex gap-2">
            <button onclick="selectAll()" class="px-3 py-1.5 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition text-sm">
                å…¨é¸
            </button>
            <button onclick="deselectAll()" class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition text-sm">
                å–æ¶ˆå…¨é¸
            </button>
            <button onclick="runSelected()" class="px-3 py-1.5 bg-green-600 text-white rounded hover:bg-green-700 transition text-sm">
                åŸ·è¡Œå·²é¸
            </button>
        </div>
    </div>

    <div class="overflow-x-auto">
        <table class="w-full text-sm">
            <thead class="bg-gray-50 border-b border-gray-200">
                <tr>
                    <th class="p-3 text-left w-12">
                        <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()" class="w-4 h-4 rounded">
                    </th>
                    <th class="p-3 text-left font-semibold text-gray-700">#</th>
                    <th class="p-3 text-left font-semibold text-gray-700">æ¸¬è©¦é›†</th>
                    <th class="p-3 text-left font-semibold text-gray-700">Prompt ç‰ˆæœ¬</th>
                    <th class="p-3 text-left font-semibold text-gray-700">Chunk ç­–ç•¥</th>
                    <th class="p-3 text-center font-semibold text-gray-700">ç‹€æ…‹</th>
                    <th class="p-3 text-center font-semibold text-gray-700">åˆ†æ•¸</th>
                    <th class="p-3 text-center font-semibold text-gray-700">æ“ä½œ</th>
                </tr>
            </thead>
            <tbody id="matrixTableBody">
                <!-- Rows will be inserted here -->
            </tbody>
        </table>
    </div>

    <div class="p-4 border-t border-gray-200 bg-gray-50 text-sm text-gray-600 text-center">
        é¡¯ç¤º <span id="visibleCount" class="font-semibold">0</span> / <span id="totalCount" class="font-semibold">0</span> å€‹çµ„åˆ
    </div>
</div>

<!-- Batch Progress Modal -->
<div id="batchProgressModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-2xl max-w-2xl w-full mx-4">
        <div class="p-6 border-b border-gray-200">
            <h3 class="text-2xl font-bold text-gray-800">æ‰¹æ¬¡åŸ·è¡Œé€²åº¦</h3>
        </div>

        <div class="p-6">
            <!-- Progress Bar -->
            <div class="mb-6">
                <div class="flex justify-between text-sm mb-2">
                    <span class="text-gray-600">æ•´é«”é€²åº¦</span>
                    <span class="font-semibold text-gray-800" id="progressText">0 / 0 (0%)</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-3">
                    <div id="progressBar" class="bg-gradient-to-r from-blue-600 to-indigo-600 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>

            <!-- Status Cards -->
            <div class="grid grid-cols-3 gap-4 mb-6">
                <div class="bg-green-50 rounded-lg p-3 border border-green-200">
                    <div class="text-green-600 text-xs font-semibold mb-1">æˆåŠŸ</div>
                    <div class="text-2xl font-bold text-green-700" id="successCount">0</div>
                </div>
                <div class="bg-red-50 rounded-lg p-3 border border-red-200">
                    <div class="text-red-600 text-xs font-semibold mb-1">å¤±æ•—</div>
                    <div class="text-2xl font-bold text-red-700" id="failCount">0</div>
                </div>
                <div class="bg-blue-50 rounded-lg p-3 border border-blue-200">
                    <div class="text-blue-600 text-xs font-semibold mb-1">å‰©é¤˜</div>
                    <div class="text-2xl font-bold text-blue-700" id="remainingCount">0</div>
                </div>
            </div>

            <!-- Progress Log -->
            <div class="bg-gray-50 rounded-lg p-4 max-h-64 overflow-y-auto" id="progressLog">
                <div class="text-sm text-gray-600 text-center">æº–å‚™é–‹å§‹...</div>
            </div>
        </div>

        <div class="p-6 border-t border-gray-200 flex justify-end gap-3">
            <button id="cancelBatchBtn" onclick="cancelBatch()" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">
                å–æ¶ˆåŸ·è¡Œ
            </button>
            <button id="closeBatchBtn" onclick="closeBatchModal()" class="hidden px-6 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">
                é—œé–‰
            </button>
        </div>
    </div>
</div>

<!-- Toast Notification -->
<div id="toast" class="hidden fixed bottom-4 right-4 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg transition-opacity z-50">
    <span id="toastMessage"></span>
</div>

<script>
let testsets = [];
let prompts = [];
let chunkStrategies = [];
let combinations = [];
let filteredCombinations = [];
let selectedCombinations = new Set();
let batchRunning = false;

// Show toast
function showToast(message, type = 'info') {
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');

    toastMessage.textContent = message;
    toast.classList.remove('hidden', 'bg-green-600', 'bg-red-600', 'bg-blue-600', 'bg-gray-800');

    if (type === 'success') {
        toast.classList.add('bg-green-600');
    } else if (type === 'error') {
        toast.classList.add('bg-red-600');
    } else if (type === 'info') {
        toast.classList.add('bg-blue-600');
    } else {
        toast.classList.add('bg-gray-800');
    }

    setTimeout(() => {
        toast.classList.add('hidden');
    }, 3000);
}

// Load all data
async function loadAllData() {
    try {
        // Load testsets
        const testsetsResponse = await fetch('/rag/api/evaluation/testsets');
        if (testsetsResponse.ok) {
            testsets = await testsetsResponse.json();
        }

        // Load prompts
        const promptsResponse = await fetch('/rag/api/evaluation/prompts');
        if (promptsResponse.ok) {
            prompts = await promptsResponse.json();
        }

        // Load chunk strategies
        const chunksResponse = await fetch('/rag/api/evaluation/chunk-strategies');
        if (chunksResponse.ok) {
            chunkStrategies = await chunksResponse.json();
        }

        // If endpoints don't exist, use sample data
        if (testsets.length === 0) testsets = getSampleTestsets();
        if (prompts.length === 0) prompts = getSamplePrompts();
        if (chunkStrategies.length === 0) chunkStrategies = getSampleChunkStrategies();

        generateCombinations();
        populateFilters();
        renderMatrix();
        updateStats();
    } catch (error) {
        console.error('Failed to load data:', error);
        // Use sample data on error
        testsets = getSampleTestsets();
        prompts = getSamplePrompts();
        chunkStrategies = getSampleChunkStrategies();
        generateCombinations();
        populateFilters();
        renderMatrix();
        updateStats();
    }
}

// Get sample data
function getSampleTestsets() {
    return [
        { id: '1', name: 'åŸºç¤æ¸¬è©¦é›†', is_active: true },
        { id: '2', name: 'é€²éšæ¸¬è©¦é›†', is_active: true }
    ];
}

function getSamplePrompts() {
    return [
        { id: '1', version: 'v1.0', name: 'é è¨­ Prompt', is_active: true },
        { id: '2', version: 'v2.0', name: 'å„ªåŒ– Prompt', is_active: true }
    ];
}

function getSampleChunkStrategies() {
    return [
        { id: '1', name: 'Recursive-å°å‹', type: 'recursive', chunk_size: 200, chunk_overlap: 40 },
        { id: '2', name: 'Recursive-ä¸­å‹', type: 'recursive', chunk_size: 400, chunk_overlap: 80 },
        { id: '3', name: 'Parent-Child-æ¨™æº–', type: 'parent_child', chunk_size: 400, chunk_overlap: 0 }
    ];
}

// Generate all combinations
function generateCombinations() {
    combinations = [];
    let index = 1;

    testsets.forEach(testset => {
        prompts.forEach(prompt => {
            chunkStrategies.forEach(chunk => {
                combinations.push({
                    id: `${testset.id}_${prompt.id}_${chunk.id}`,
                    index: index++,
                    testset: testset,
                    prompt: prompt,
                    chunk: chunk,
                    status: 'pending', // pending, running, completed, failed
                    score: null,
                    experiment_id: null
                });
            });
        });
    });

    filteredCombinations = [...combinations];
}

// Populate filters
function populateFilters() {
    const testsetFilter = document.getElementById('filterTestset');
    const promptFilter = document.getElementById('filterPrompt');
    const chunkFilter = document.getElementById('filterChunk');

    testsets.forEach(t => {
        const option = document.createElement('option');
        option.value = t.id;
        option.textContent = t.name;
        testsetFilter.appendChild(option);
    });

    prompts.forEach(p => {
        const option = document.createElement('option');
        option.value = p.id;
        option.textContent = `${p.version} - ${p.name}`;
        promptFilter.appendChild(option);
    });

    chunkStrategies.forEach(c => {
        const option = document.createElement('option');
        option.value = c.id;
        option.textContent = c.name;
        chunkFilter.appendChild(option);
    });
}

// Apply filters
function applyFilters() {
    const testsetFilter = document.getElementById('filterTestset').value;
    const promptFilter = document.getElementById('filterPrompt').value;
    const chunkFilter = document.getElementById('filterChunk').value;

    filteredCombinations = combinations.filter(combo => {
        if (testsetFilter !== 'all' && combo.testset.id !== testsetFilter) return false;
        if (promptFilter !== 'all' && combo.prompt.id !== promptFilter) return false;
        if (chunkFilter !== 'all' && combo.chunk.id !== chunkFilter) return false;
        return true;
    });

    renderMatrix();
    updateStats();
}

// Render matrix table
function renderMatrix() {
    const tbody = document.getElementById('matrixTableBody');

    if (filteredCombinations.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="p-8 text-center text-gray-500">ç„¡ç¬¦åˆæ¢ä»¶çš„çµ„åˆ</td></tr>';
        document.getElementById('visibleCount').textContent = '0';
        document.getElementById('totalCount').textContent = combinations.length;
        return;
    }

    tbody.innerHTML = filteredCombinations.map(combo => `
        <tr class="border-b border-gray-100 hover:bg-gray-50">
            <td class="p-3">
                <input type="checkbox" class="combo-checkbox w-4 h-4 rounded" data-id="${combo.id}"
                       ${selectedCombinations.has(combo.id) ? 'checked' : ''}
                       onchange="toggleSelection('${combo.id}')">
            </td>
            <td class="p-3 text-gray-600">#${combo.index}</td>
            <td class="p-3">
                <div class="font-medium text-gray-800">${combo.testset.name}</div>
            </td>
            <td class="p-3">
                <div class="text-sm">
                    <span class="font-semibold text-blue-600">${combo.prompt.version}</span>
                    <div class="text-gray-600">${combo.prompt.name}</div>
                </div>
            </td>
            <td class="p-3">
                <div class="text-sm">
                    <span class="font-semibold text-purple-600">${combo.chunk.name}</span>
                    <div class="text-gray-500">${combo.chunk.chunk_size} / ${combo.chunk.chunk_overlap}</div>
                </div>
            </td>
            <td class="p-3 text-center">
                ${getStatusBadge(combo.status)}
            </td>
            <td class="p-3 text-center">
                ${combo.score !== null ? `<span class="font-bold text-green-600">${combo.score.toFixed(3)}</span>` : '<span class="text-gray-400">-</span>'}
            </td>
            <td class="p-3 text-center">
                <button onclick="runSingleExperiment('${combo.id}')"
                        class="px-3 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700 transition"
                        ${combo.status === 'running' ? 'disabled' : ''}>
                    ${combo.status === 'running' ? 'åŸ·è¡Œä¸­...' : 'åŸ·è¡Œ'}
                </button>
            </td>
        </tr>
    `).join('');

    document.getElementById('visibleCount').textContent = filteredCombinations.length;
    document.getElementById('totalCount').textContent = combinations.length;
}

// Get status badge
function getStatusBadge(status) {
    const badges = {
        'pending': '<span class="px-2 py-1 bg-gray-100 text-gray-600 rounded text-xs font-medium">å¾…åŸ·è¡Œ</span>',
        'running': '<span class="px-2 py-1 bg-blue-100 text-blue-600 rounded text-xs font-medium">åŸ·è¡Œä¸­</span>',
        'completed': '<span class="px-2 py-1 bg-green-100 text-green-600 rounded text-xs font-medium">å·²å®Œæˆ</span>',
        'failed': '<span class="px-2 py-1 bg-red-100 text-red-600 rounded text-xs font-medium">å¤±æ•—</span>'
    };
    return badges[status] || badges.pending;
}

// Update stats
function updateStats() {
    const completed = combinations.filter(c => c.status === 'completed').length;
    const running = combinations.filter(c => c.status === 'running').length;
    const pending = combinations.filter(c => c.status === 'pending').length;
    const total = combinations.length;
    const rate = total > 0 ? Math.round(completed / total * 100) : 0;

    document.getElementById('totalCombinations').textContent = total;
    document.getElementById('completedCount').textContent = completed;
    document.getElementById('pendingCount').textContent = pending;
    document.getElementById('runningCount').textContent = running;
    document.getElementById('completionRate').textContent = rate + '%';
}

// Selection functions
function toggleSelection(id) {
    if (selectedCombinations.has(id)) {
        selectedCombinations.delete(id);
    } else {
        selectedCombinations.add(id);
    }
}

function toggleSelectAll() {
    const checkbox = document.getElementById('selectAllCheckbox');
    if (checkbox.checked) {
        selectAll();
    } else {
        deselectAll();
    }
}

function selectAll() {
    filteredCombinations.forEach(combo => {
        selectedCombinations.add(combo.id);
    });
    document.querySelectorAll('.combo-checkbox').forEach(cb => cb.checked = true);
    document.getElementById('selectAllCheckbox').checked = true;
}

function deselectAll() {
    selectedCombinations.clear();
    document.querySelectorAll('.combo-checkbox').forEach(cb => cb.checked = false);
    document.getElementById('selectAllCheckbox').checked = false;
}

// Run single experiment
async function runSingleExperiment(comboId) {
    const combo = combinations.find(c => c.id === comboId);
    if (!combo) return;

    showToast(`é–‹å§‹åŸ·è¡Œï¼š${combo.testset.name} Ã— ${combo.prompt.version} Ã— ${combo.chunk.name}`, 'info');

    // Update status
    combo.status = 'running';
    renderMatrix();
    updateStats();

    // Simulate API call (replace with real API)
    try {
        // TODO: Replace with real API call
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Simulate random score
        combo.score = 0.6 + Math.random() * 0.4;
        combo.status = 'completed';

        showToast('å¯¦é©—åŸ·è¡ŒæˆåŠŸï¼', 'success');
    } catch (error) {
        combo.status = 'failed';
        showToast('å¯¦é©—åŸ·è¡Œå¤±æ•—ï¼š' + error.message, 'error');
    }

    renderMatrix();
    updateStats();
}

// Run selected experiments
async function runSelected() {
    if (selectedCombinations.size === 0) {
        showToast('è«‹å…ˆé¸æ“‡è¦åŸ·è¡Œçš„çµ„åˆ', 'error');
        return;
    }

    const selectedList = Array.from(selectedCombinations)
        .map(id => combinations.find(c => c.id === id))
        .filter(c => c && c.status === 'pending');

    if (selectedList.length === 0) {
        showToast('æ‰€é¸çµ„åˆå·²å…¨éƒ¨åŸ·è¡Œ', 'error');
        return;
    }

    runBatchExperiments(selectedList);
}

// Run all experiments
async function runAllExperiments() {
    const pendingList = combinations.filter(c => c.status === 'pending');

    if (pendingList.length === 0) {
        showToast('æ‰€æœ‰çµ„åˆå·²åŸ·è¡Œå®Œæˆ', 'info');
        return;
    }

    if (!confirm(`ç¢ºå®šè¦åŸ·è¡Œå…¨éƒ¨ ${pendingList.length} å€‹çµ„åˆå—ï¼Ÿé€™å¯èƒ½éœ€è¦è¼ƒé•·æ™‚é–“ã€‚`)) {
        return;
    }

    runBatchExperiments(pendingList);
}

// Run batch experiments
async function runBatchExperiments(experimentList) {
    batchRunning = true;

    // Show modal
    const modal = document.getElementById('batchProgressModal');
    modal.classList.remove('hidden');

    // Initialize progress
    const total = experimentList.length;
    let completed = 0;
    let success = 0;
    let failed = 0;

    document.getElementById('progressText').textContent = `0 / ${total} (0%)`;
    document.getElementById('successCount').textContent = '0';
    document.getElementById('failCount').textContent = '0';
    document.getElementById('remainingCount').textContent = total;
    document.getElementById('progressBar').style.width = '0%';
    document.getElementById('progressLog').innerHTML = '<div class="text-sm text-gray-600">é–‹å§‹æ‰¹æ¬¡åŸ·è¡Œ...</div>';

    // Hide cancel, show close button when done
    document.getElementById('cancelBatchBtn').classList.remove('hidden');
    document.getElementById('closeBatchBtn').classList.add('hidden');

    // Run experiments sequentially
    for (const combo of experimentList) {
        if (!batchRunning) {
            addProgressLog(`âŒ æ‰¹æ¬¡åŸ·è¡Œå·²å–æ¶ˆ`, 'error');
            break;
        }

        addProgressLog(`ğŸ”„ åŸ·è¡Œï¼š${combo.testset.name} Ã— ${combo.prompt.version} Ã— ${combo.chunk.name}`);

        combo.status = 'running';
        renderMatrix();
        updateStats();

        try {
            // TODO: Replace with real API call
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Simulate random score
            combo.score = 0.6 + Math.random() * 0.4;
            combo.status = 'completed';
            success++;

            addProgressLog(`âœ… å®Œæˆï¼šåˆ†æ•¸ ${combo.score.toFixed(3)}`, 'success');
        } catch (error) {
            combo.status = 'failed';
            failed++;
            addProgressLog(`âŒ å¤±æ•—ï¼š${error.message}`, 'error');
        }

        completed++;
        const progress = Math.round(completed / total * 100);

        // Update progress
        document.getElementById('progressText').textContent = `${completed} / ${total} (${progress}%)`;
        document.getElementById('progressBar').style.width = progress + '%';
        document.getElementById('successCount').textContent = success;
        document.getElementById('failCount').textContent = failed;
        document.getElementById('remainingCount').textContent = total - completed;

        renderMatrix();
        updateStats();
    }

    // Show completion
    if (batchRunning) {
        addProgressLog(`\nğŸ‰ æ‰¹æ¬¡åŸ·è¡Œå®Œæˆï¼æˆåŠŸï¼š${success}ï¼Œå¤±æ•—ï¼š${failed}`, 'success');
    }

    // Show close button
    document.getElementById('cancelBatchBtn').classList.add('hidden');
    document.getElementById('closeBatchBtn').classList.remove('hidden');

    batchRunning = false;
}

// Add progress log
function addProgressLog(message, type = 'info') {
    const log = document.getElementById('progressLog');
    const entry = document.createElement('div');
    entry.className = 'text-sm mb-1';

    if (type === 'success') {
        entry.className += ' text-green-600';
    } else if (type === 'error') {
        entry.className += ' text-red-600';
    } else {
        entry.className += ' text-gray-700';
    }

    entry.textContent = message;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

// Cancel batch
function cancelBatch() {
    if (confirm('ç¢ºå®šè¦å–æ¶ˆæ‰¹æ¬¡åŸ·è¡Œå—ï¼Ÿ')) {
        batchRunning = false;
        showToast('æ‰¹æ¬¡åŸ·è¡Œå·²å–æ¶ˆ', 'info');
    }
}

// Close batch modal
function closeBatchModal() {
    document.getElementById('batchProgressModal').classList.add('hidden');
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    loadAllData();
});
</script>
{% endblock %}
