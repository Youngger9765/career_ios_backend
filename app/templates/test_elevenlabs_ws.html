<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ElevenLabs WebSocket æ¸¬è©¦</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        #log {
            background: #252526;
            padding: 15px
            border-radius: 5px
            height: 500px
            overflow-y: auto
            white-space: pre-wrap
            word-wrap: break-word
        }
        button {
            padding: 10px 20px;
            margin: 10px 5px;
            font-size: 14px;
            cursor: pointer;
        }
        .success { color: #4EC9B0; }
        .error { color: #F48771; }
        .info { color: #9CDCFE; }
        .warning { color: #CE9178; }
    </style>
</head>
<body>
    <h1>ğŸ¤ ElevenLabs Speech-to-Text WebSocket æ¸¬è©¦</h1>
    <div>
        <button onclick="testConnection()">æ¸¬è©¦é€£ç·š</button>
        <button onclick="testWithAudio()">æ¸¬è©¦éŸ³è¨Šå‚³è¼¸</button>
        <button onclick="disconnect()">ä¸­æ–·é€£ç·š</button>
        <button onclick="clearLog()">æ¸…é™¤ Log</button>
    </div>
    <div id="log"></div>

    <script>
        let ws = null;
        let audioContext = null;
        let audioStream = null;
        let elevenlabsToken = null;  // Store token from backend

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('zh-TW', { hour12: false });
            const logDiv = document.getElementById('log');
            const line = document.createElement('div');
            line.className = type;
            line.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        async function testConnection() {
            log('ğŸ”Œ é–‹å§‹æ¸¬è©¦ WebSocket é€£ç·š...', 'info');

            try {
                // Step 1: Get token from backend
                log('ğŸ“ å‘¼å«å¾Œç«¯å–å¾— token...', 'info');
                const tokenResponse = await fetch('/api/v1/transcript/elevenlabs-token', {
                    method: 'POST'
                });

                if (!tokenResponse.ok) {
                    throw new Error(`Token ç”Ÿæˆå¤±æ•—: ${tokenResponse.status}`);
                }

                const { token } = await tokenResponse.json();
                elevenlabsToken = token;
                log(`âœ… Token å–å¾—æˆåŠŸ: ${token.substring(0, 20)}...`, 'success');

                // Step 2: å»ºç«‹ WebSocket é€£ç·šï¼ˆåªæ¸¬è©¦é€£ç·šï¼Œä¸å‚³éŸ³è¨Šï¼‰
                // ä½¿ç”¨ token parameter è€Œé xi-api-key header (ç€è¦½å™¨ WebSocket ä¸æ”¯æ´è‡ªè¨‚ header)
                const wsUrl = `wss://api.elevenlabs.io/v1/speech-to-text/realtime?` +
                    `token=${elevenlabsToken}` +
                    `&audio_format=pcm_16000` +
                    `&language=zh` +
                    `&commit_strategy=vad`;

                log('ğŸ“¡ WebSocket URL: ' + wsUrl.replace(elevenlabsToken, 'HIDDEN_TOKEN'), 'info');

                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    log('âœ… WebSocket é€£ç·šæˆåŠŸï¼', 'success');
                };

                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    log('ğŸ“¨ æ”¶åˆ°è¨Šæ¯:', 'info');
                    log(JSON.stringify(message, null, 2), 'info');

                    // æª¢æŸ¥è¨Šæ¯é¡å‹
                    if (message.status === 'started') {
                        log('âœ… Session å·²å•Ÿå‹•ï¼', 'success');
                    }
                };

                ws.onerror = (error) => {
                    log('âŒ WebSocket éŒ¯èª¤: ' + error, 'error');
                };

                ws.onclose = (event) => {
                    log(`ğŸ”Œ WebSocket é—œé–‰ (code: ${event.code}, reason: ${event.reason})`, 'warning');
                    if (!event.wasClean) {
                        log('âš ï¸ é€£ç·šç•°å¸¸é—œé–‰', 'warning');
                    }
                };

            } catch (error) {
                log('âŒ éŒ¯èª¤: ' + error.message, 'error');
            }
        }

        async function testWithAudio() {
            log('ğŸ¤ é–‹å§‹æ¸¬è©¦éŸ³è¨Šå‚³è¼¸...', 'info');

            try {
                // å…ˆå»ºç«‹ WebSocket
                await testConnection();

                // ç­‰å¾… 1 ç§’ç¢ºä¿é€£ç·šå»ºç«‹
                await new Promise(resolve => setTimeout(resolve, 1000));

                // è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™
                log('ğŸ™ï¸ è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...', 'info');
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                log('âœ… éº¥å…‹é¢¨å­˜å–æˆåŠŸ', 'success');

                // å»ºç«‹ AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                const source = audioContext.createMediaStreamSource(audioStream);

                // å»ºç«‹éŸ³è¨Šè™•ç†ç¯€é»
                const processor = audioContext.createScriptProcessor(4096, 1, 1);

                let chunkCount = 0;
                processor.onaudioprocess = (e) => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const inputData = e.inputBuffer.getChannelData(0);

                        // è½‰æ›ç‚º Int16 PCM
                        const pcmData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            const s = Math.max(-1, Math.min(1, inputData[i]));
                            pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        // è½‰æ›ç‚º Base64
                        const base64Audio = arrayBufferToBase64(pcmData.buffer);

                        // ç™¼é€åˆ° ElevenLabsï¼ˆæ­£ç¢ºçš„ JSON æ ¼å¼ï¼‰
                        const message = {
                            message_type: 'input_audio_chunk',
                            audio_base_64: base64Audio,
                            commit: false,  // Auto-commit ç”± VAD è™•ç†
                            sample_rate: 16000
                        };
                        ws.send(JSON.stringify(message));

                        chunkCount++;
                        if (chunkCount % 10 === 0) {
                            log(`ğŸ“¤ å·²ç™¼é€ ${chunkCount} å€‹éŸ³è¨Šç‰‡æ®µ`, 'info');
                        }
                    }
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                log('âœ… éŸ³è¨Šä¸²æµå·²å•Ÿå‹•ï¼Œè«‹å°éº¥å…‹é¢¨èªªè©±...', 'success');
                log('â±ï¸ å°‡æŒçºŒ 10 ç§’å¾Œè‡ªå‹•åœæ­¢', 'warning');

                // 10 ç§’å¾Œè‡ªå‹•åœæ­¢
                setTimeout(() => {
                    disconnect();
                    log('â¹ï¸ æ¸¬è©¦å®Œæˆ', 'info');
                }, 10000);

            } catch (error) {
                log('âŒ éŒ¯èª¤: ' + error.message, 'error');
            }
        }

        function disconnect() {
            if (audioContext) {
                audioContext.close();
                audioContext = null;
                log('â¹ï¸ AudioContext å·²é—œé–‰', 'info');
            }

            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
                log('ğŸ¤ éº¥å…‹é¢¨å·²é‡‹æ”¾', 'info');
            }

            if (ws) {
                ws.close();
                ws = null;
                log('ğŸ”Œ WebSocket å·²é—œé–‰', 'info');
            }
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // é é¢å¸è¼‰æ™‚æ¸…ç†è³‡æº
        window.addEventListener('beforeunload', disconnect);
    </script>
</body>
</html>
